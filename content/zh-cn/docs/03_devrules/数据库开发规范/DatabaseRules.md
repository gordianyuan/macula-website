---
title: "数据库规范"
linkTitle: "数据库规范"
weight: 1
---
## 命名规范

1.1 整体规约

数据库对象名仅可包含小写英文字母、数字、下划线（_）三类字符，并以英文字母开头 
数据库对象命名禁止使用MySQL保留字
多个单词之间用下划线（_）分隔
对象名称长度若超过限制，则使用简写/缩写命名 
数据库命名尽量不超过30个字符

1.2 表名

(1)所属同一模块的表必须以模块名作为前缀命名。例如：
会员中心的前缀为“member_”；
库存中心的前缀为“stock_”； 
(2) 后缀命名规则
历史数据表在原表基础上增加"_his"后缀命名；
日志表在原表基础上增加"_log"后缀命名；
临时表增加"_tmp"后缀命名；
备份表增加"_bak当前日期"后缀命名，比如 test_bak20220617； 
(3) 下划线分隔
表名有多个单词组合，则用下划线（_）分隔； 

1.3 字段名

表的字段数不超过50个
各表之间相同含义的字段,类型定义要完全相同（包括精度、默认值等）
字段命名及其注释,要做到清楚、无歧义
布尔意义的字段以"is_"作为前缀。比如is_del、is_flag、is_enabled等 

1.4 普通索引

命名规范 IDX_tablename_数字，比如IDX_DT_DEALER_01,第二个普通索引就叫 IDX_DT_DEALER_02，以此类推。 

1.5 唯一索引

命名规范 IDX_tablename_U数字，比如IDX_DT_STORE_U1,第二个唯一索引就叫 IDX_DT_STORE_U2，以此类推。

## 表设计规范
2.1、所有表必须使用Innodb存储引擎

没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

2.2、数据库和表的字符集统一使用

MYSQL 8.0及以下版本，使用UTF8，MYSQL 8.0及以上版本，使用utf8mb4。

2.3、所有表和字段都需要添加注释

使用comment从句添加表和列的备注 从一开始就进行数据字典的维护。

2.4、尽量控制单表数据量的大小，建议控制在500万以内

500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。

2.5、谨慎使用MySQL分区表

分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据

2.6、尽量做到冷热数据分离，减小表的宽度

MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）

2.7、禁止在表中建立预留字段

预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定

2.8、禁止在数据库中存储图片，文件等大的二进制数据

通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息

2.9、禁止在线上做数据库压力测试

2.10、禁止非生产机器直连生产数据库 

## 字段设计规范
3.1、优先选择符合存储需要的最小的数据类型

列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差

3.2、避免使用TEXT、BLOB数据类型

最常见的TEXT类型可以存储64k的数据
建议把BLOB或是TEXT列分离到单独的扩展表中。Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。
如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。 
TEXT或BLOB类型只能使用前缀索引。因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。

3.3、避免使用ENUM类型

修改ENUM值需要使用ALTER语句
ENUM类型的ORDER BY操作效率低，需要额外操作
禁止使用数值作为ENUM的枚举值

3.4、尽可能把所有列定义为NOT NULL

这样要求的原因：
索引NULL列需要额外的空间来保存，所以要占用更多的空间；
进行比较和计算时要对NULL值做特别的处理

3.5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间

TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。
TIMESTAMP 占用4字节和INT相同，但比INT可读性高。超出TIMESTAMP取值范围的使用DATETIME类型存储。
经常会有人用字符串存储日期型的数据（不正确的做法）：
缺点1：无法用日期函数进行计算和比较
缺点2：用字符串存储日期要占用更多的空间

3.6、同财务相关的金额类数据必须使用decimal类型

非精准浮点：float,double
精准浮点：decimal
Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。

## 索引设计规范 
4.1、限制每张表上的索引数量，建议单张表索引不超过5个

索引并不是越多越好！索引可以提高效率同样可以降低效率。索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。

4.2、禁止给表中的每一列都建立单独的索引

5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好

4.3、每个Innodb表必须有个主键

Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。主键建议使用自增ID值。

4.4、常见索引列建议

出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列
包含在ORDER BY、GROUP BY、DISTINCT中的字段，并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好
多表join的关联列 

